package generator

import (
	"fmt"
	"github.com/bigkucha/model-generator/database"
	"github.com/bigkucha/model-generator/helper"
	"github.com/dave/jennifer/jen"
	"github.com/jinzhu/inflection"
	"github.com/urfave/cli"
	"os"
	"strings"
)

func Generate(c *cli.Context) error {
	dbSns := fmt.Sprintf("%s:%s@/%s?charset=utf8&parseTime=True&loc=Local",
		c.String("u"), c.String("p"), c.String("d"))
	db := database.GetDB(dbSns)
	appId := c.String("appId")
	daoDir := c.String("daodir")
	tableName := c.String("t")
	if tableName == "ALL" {
		tables := db.GetDataBySql("show tables")
		for _, table := range tables {
			tableName := table["Tables_in_"+c.String("d")]
			columns := db.GetDataBySql("desc " + tableName)
			generateModel(tableName, columns, c.String("dir"))
			generateDao(appId, tableName, daoDir)
		}
	} else {
		columns := db.GetDataBySql("desc " + tableName)
		generateModel(tableName, columns, c.String("dir"))
		generateDao(appId, tableName, daoDir)
	}
	return nil
}

func generateDao(appId, tableName, dir string) {
	index := strings.LastIndex(dir, "/")
	daoPackage := dir[index+1 : len(dir)]
	f := jen.NewFile(daoPackage)
	f.HeaderComment("Code generated by model-generator.")
	f.ImportAlias(appId+"/model", "model")
	f.ImportAlias(appId+"/proto", appId)
	f.ImportAlias("time", "time")
	createFun(f, appId, tableName)
	_ = os.MkdirAll(dir, os.ModePerm)
	fileName := dir + "/" + inflection.Singular(tableName) + ".dao.go"
	if err := f.Save(fileName); err != nil {
		fmt.Println(err.Error())
	}

	fmt.Println(fileName)
}

func createFun(f *jen.File, appId, tableName string) {
	entityName := helper.SnakeCase2CamelCase(inflection.Singular(tableName), true)
	f.Func().Params(
		jen.Id("d *Dao"),
	).Id("Create" + entityName).Params(
		jen.Id("entity").Id("*").Qual(appId+"/model", entityName),
	).Params(
		jen.Id("uint"),
		jen.Id("error"),
	).Block(
		jen.Id("result").Op(":=").Id("d").Dot("client").Dot("Table").Call(
			jen.Lit(tableName),
		).Dot("Create").Call(
			jen.Id("entity"),
		),
		jen.Return(
			jen.Id("entity").Dot("ID"),
			jen.Id("result").Dot("Error"),
		),
	)
}

func generateModel(tableName string, columns []map[string]string, dir string) {
	index := strings.LastIndex(dir, "/")
	daoPackage := dir[index+1 : len(dir)]
	var codes []jen.Code
	for _, col := range columns {
		t := col["Type"]
		column := col["Field"]
		var st *jen.Statement
		if column == "id" {
			st = jen.Id("ID").Uint().Tag(map[string]string{"json": "id"})
		} else {
			st = jen.Id(helper.SnakeCase2CamelCase(column, true))
			getCol(st, t)
			st.Tag(map[string]string{"json": column})
		}
		codes = append(codes, st)
	}
	f := jen.NewFile(daoPackage)
	f.HeaderComment("Code generated by model-generator. DO NOT EDIT.")
	f.ImportAlias("time", "time")
	f.Type().Id(helper.SnakeCase2CamelCase(inflection.Singular(tableName), true)).Struct(codes...)
	_ = os.MkdirAll(dir, os.ModePerm)
	fileName := dir + "/" + inflection.Singular(tableName) + ".go"
	fmt.Println(fileName)
	if err := f.Save(fileName); err != nil {
		fmt.Println(err.Error())
	}
}

func getCol(st *jen.Statement, t string) {
	prefix := strings.Split(t, "(")[0]
	switch prefix {
	case "int", "tinyint", "smallint", "bigint", "mediumint":
		st.Int()
	case "float":
		st.Float32()
	case "decimal":
		st.Float32()
	case "date", "time", "timestamp", "year", "datetime":
		st.Id("*").Qual("time", "Time")
	default:
		st.String()
	}
}
